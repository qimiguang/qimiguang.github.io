---
title: 推荐系统常用算法
date: 2017-10-19 09:15:00
tags:
- Recommender
- Collaborative Filtering 
- Machine Learning
---

上次简单聊了下推荐系统的基本概念和用户行为的一些知识，今天来聊下推荐系统中常用的算法及应用场景。
![](/assets/images/recommender/alg.jpeg)
如图所示，推荐系统算法分为两大类：Content-based Filtering（基于内容的过滤） & Collaborative Filtering（协同过滤）。由于所涉及到的知识点很多，我们先来了解下协同过滤。

# Collaborative Filtering
协同过滤算是使用非常广泛的推荐系统算法，它通过收集 & 分析大量的<span style="color:red">用户行为数据</span>来预测用户对某个内容的喜好程度。它基于这样的假设：用户将会喜欢与过去喜欢过的 items 相似的 items。

场景方面，Facebook、LinkedIn 以及一些别的社交网络公司使用协同过滤给用户推荐好友、群组等，Twitter 给用户推荐 follow 人选等，Amazon、Netflix、 Youtube 给用户推荐一些用户可能感兴趣的物品。

[上篇文章](https://qimiguang.github.io/2017/10/19/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/)提到，用户行为数据又分显性反馈和隐性反馈。协同过滤对这两种的处理方式也有不同。

具体来说，协同过滤又分为两种类型：Neighborhood Methods（基于领域的方法）、Latent Factor Models（隐语义模型）。

## Neighborhood-Based Collaborative Filtering
基于领域的方法包含 user-based CF（基于用户的协同过滤） & item-based CF（基于物品的协同过滤）

### User-based CF
基于用户的协同过滤算法：给用户推荐和他兴趣相似的其他用户喜欢的物品。它是推荐系统中最古老的算法，当然现在在大部分场景中已经被 Item-based CF / Latent Factor Models 算法替代了。具体来说，该算法包含两步：

* 找出和目标用户有最多**相似兴趣度**的用户集合
* 找出该集合中的用户喜欢的，但是目标用户没听过的物品，按照优先级推荐给目标用户

![](/assets/images/recommender/user-based.jpeg)
上图是 User-based CF 的一个简单公式，其中 p(u,i) 即预测用户 u 对 物品 i 的喜好程度，W<sub>uv</sub> 表示用户 u 和用户 v 的相似度，r<sub>vi</sub> 表示用户 v 对物品 i 的喜好程度。

这里提到一个相似度的问题，数学上有很多种方式计算相似度，包括欧式距离、皮尔逊相关系数、余弦相似度、Jaccard相关系数、汉明距离甚至 TF-IDF 等等等等，不同的场景使用不同的相似度算法，这里就先不一一展开了（以后可能会专门写篇博客谈这个问题吧。。。）。

当然了，真实场景下计算用户的相似度不会像上面那么简单，举个简单例子，《Harry Potter》可能人人都买过，但是这丝毫不能说明这些人相互之间有多少相似度，而如果两人同时购买了《Python For Data Analysis》这种更专业更冷门的物品，则更可以说明两人有类似的兴趣，这就是推荐系统领域著名的 [Harry Potter Problem](http://nkparimi.blogspot.jp/2010/01/harry-potter-problem.html)。所以计算用户相似度的时候，需要考虑对热门物品进行惩罚：
![](/assets/images/recommender/hot-user.png)

### Item-based CF
基于物品的协同过滤算法：给用户推荐和他之前喜欢的物品相似的物品。它也是目前用的**非常广泛**的算法，和 User-based CF 类似，该算法也主要分为两步：

* 计算物品之间的相似度
* 根据物品的相似度和用户历史行为给用户生成推荐列表

需要注意的是，物品之间的相似度是根据分析用户行为来计算的（item A is similar with item B 是因为有大量用户同时喜欢了两者），而不是通过物品本身的内容属性（如标题、出版社等具体的 features）。

![](/assets/images/recommender/item-based.png)
同样的，Item-based CF 也需要考虑活跃用户的影响，即一个活跃用户（专门做刷单）可能买了非常多的物品，

使用 Item-based CF 最典型的例子是 Amazon:
![](/assets/images/recommender/amazon-recom.jpeg)


![](/assets/images/recommender/)
![](/assets/images/recommender/)
![](/assets/images/recommender/)


可以看出，User-based CF 和 Item-based CF 思想其实有很多相似的地方，不同之处在于，User-based CF 是基于**用户和用户**之间的相似度来推荐，而 Item-based CF 是基于**物品和物品**之间的相似度来推荐。


Collaborative filtering approaches often suffer from three problems: cold start, scalability, and sparsity.[37]

## Comparison
经过上面的描述后，User-based CF 和

User-based CF 需要维护一个 user-user 的矩阵，随着用户量的增大，时间复杂度和空间复杂度会以平方关系增大。

# 新闻场景

## Latent Factor Models


# REFERENCES
[Recommender system in wikipedia](https://en.wikipedia.org/wiki/Recommender_system#Approaches)
[Recommender Systems Handbook](http://www.springer.com/us/book/9780387858203)
[Neighborhood-Based Collaborative Filtering](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwiV9OaFo6XXAhVGjZQKHYHSC8cQFggtMAA&url=http%3A%2F%2Fwww.springer.com%2Fcda%2Fcontent%2Fdocument%2Fcda_downloaddocument%2F9783319296579-c1.pdf%3FSGWID%3D0-0-45-1554478-p179516130&usg=AOvVaw15tMwXNsAAp8kp7_GlelXI)

